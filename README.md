# Dirvana

A lightweight, fast, and fully testable CLI tool that automatically loads shell aliases, functions, and environment variables per folder. Perfect for managing project-specific shell environments.

## Features

- 🚀 **Fast**: Minimal overhead (<10ms) with intelligent caching
- 🔒 **Secure**: Authorization system to control which projects can execute
- 🌳 **Hierarchical**: Merge configurations from parent directories
- 📝 **Flexible**: Support for YAML, TOML, and JSON formats
- 🧪 **Testable**: Built with TDD, 90%+ test coverage
- 🐚 **Compatible**: Works with Bash, Zsh, Fish, and PowerShell

## Installation

### Using Homebrew (macOS/Linux)

```bash
brew install NikitaCOEUR/tap/dirvana
```

### Using go install

```bash
go install github.com/NikitaCOEUR/dirvana/cmd/dirvana@latest
```

### Download Binary

Download the latest release from [GitHub Releases](https://github.com/NikitaCOEUR/dirvana/releases) for your platform.

### Using Docker

```bash
docker pull ghcr.io/nikitacoeur/dirvana:latest
docker run --rm ghcr.io/nikitacoeur/dirvana:latest --version
```

### From Source

```bash
git clone https://github.com/NikitaCOEUR/dirvana.git
cd dirvana
task install
```

### Setup Shell Hook

Automatically install the shell hook:

```bash
dirvana setup
```

Or manually add to your `~/.bashrc` or `~/.zshrc`:

```bash
source /path/to/dirvana/hooks/dirvana.sh
```

## Quick Start

1. **Initialize a project** (creates `.dirvana.yml` with JSON Schema validation):
```bash
cd your-project
dirvana init
```

2. **Authorize the project**:
```bash
dirvana allow
```

3. **Reload your shell** or source your rc file:
```bash
source ~/.bashrc  # or ~/.zshrc
```

Your aliases, functions, and environment variables are now loaded!

## Configuration

Dirvana supports two types of configuration files:

1. **Global config**: `~/.config/dirvana/global.yml` - Applied to all projects
2. **Local configs**: `.dirvana.yml` in project directories - Project-specific settings

Configuration files are merged in this order: global → root → parent → current directory (child configs override parent values).

### YAML Example

All configuration files generated by `dirvana init` or `dirvana edit` automatically include JSON Schema validation for IDE support (auto-completion, validation, documentation).

```yaml
# yaml-language-server: $schema=https://raw.githubusercontent.com/NikitaCOEUR/dirvana/main/schema/dirvana.schema.json

# Aliases - shortcuts for common commands
aliases:
  ll: ls -lah
  gs: git status
  build: go build -o bin/app ./cmd

# Functions - reusable command sequences
functions:
  mkcd: |
    mkdir -p "$1" && cd "$1"
  gcm: |
    git commit -m "$1"

# Environment variables
env:
  # Static values
  PROJECT_NAME: myproject
  DEBUG: "true"
  LOG_LEVEL: debug

  # Dynamic values from shell commands (like Taskfile)
  GIT_BRANCH:
    sh: git rev-parse --abbrev-ref HEAD
  PROJECT_ROOT:
    sh: pwd

# Prevent merging with parent configs (only use this directory's config)
local_only: false

# Ignore global config (start fresh from this directory)
ignore_global: false
```

### Dynamic Environment Variables

Dirvana supports dynamic environment variables that are evaluated at load time using shell commands (similar to Taskfile's `sh` syntax):

```yaml
env:
  # Static value
  PROJECT_NAME: myproject

  # Dynamic value - executes shell command
  GIT_BRANCH:
    sh: git rev-parse --abbrev-ref HEAD

  CURRENT_USER:
    sh: whoami

  BUILD_TIME:
    sh: date +%s
```

The shell commands are executed when the configuration is loaded, and the output becomes the environment variable value.

### Global Configuration

Create a global config at `~/.config/dirvana/global.yml` (or `$XDG_CONFIG_HOME/dirvana/global.yml`) to apply settings across all projects:

```yaml
# Global aliases available everywhere
aliases:
  ll: ls -lah
  g: git
  d: docker

# Global environment variables
env:
  EDITOR: vim
  PAGER: less

# Global functions
functions:
  mkcd: |
    mkdir -p "$1" && cd "$1"
```

Local configurations can:
- Add to or override global settings
- Ignore global config entirely with `ignore_global: true`
- Use `local_only: true` to prevent merging with parent directories (but still merge with global)

See the `examples/` directory for more configuration examples.

### IDE Integration with JSON Schema

For auto-completion and validation in your editor, add the schema reference to your config files:

**YAML:**
```yaml
# yaml-language-server: $schema=https://raw.githubusercontent.com/NikitaCOEUR/dirvana/main/schema/dirvana.schema.json

aliases:
  ll: ls -lah
```

**VS Code settings.json (workspace or user):**
```json
{
  "yaml.schemas": {
    "https://raw.githubusercontent.com/NikitaCOEUR/dirvana/main/schema/dirvana.schema.json": [
      ".dirvana.yml",
      ".dirvana.yaml"
    ]
  }
}
```

**Generate schema locally:**
```bash
dirvana schema -o .vscode/dirvana.schema.json
```

This enables:
- ✨ Auto-completion for configuration keys
- 🔍 Inline documentation for all options
- ⚠️ Real-time validation errors
- 💡 IntelliSense suggestions

## Environment Variables

All command parameters can be set via environment variables with the `DIRVANA_` prefix:

```bash
# Set log level (debug, info, warn, error)
DIRVANA_LOG_LEVEL=debug cd ~/project

# Set shell type for hook/setup commands
DIRVANA_SHELL=zsh dirvana hook

# Set previous directory (used internally by the hook)
DIRVANA_PREV=/old/path dirvana export
```

## Commands

### `dirvana export`
Export shell code for the current folder. This is automatically called by the shell hook.

```bash
eval "$(dirvana export)"
```

Flags:
- `--prev` : Previous directory for context cleanup (also via `DIRVANA_PREV`)
- `--log-level` : Log level - debug, info, warn, error (also via `DIRVANA_LOG_LEVEL`, default: warn)

### `dirvana allow [path]`
Authorize a project for automatic execution. Without path, authorizes current directory.

```bash
dirvana allow
dirvana allow /path/to/project
```

### `dirvana revoke [path]`
Revoke authorization for a project.

```bash
dirvana revoke
dirvana revoke /path/to/project
```

### `dirvana list`
List all authorized projects.

```bash
dirvana list
```

### `dirvana status`
Show current Dirvana configuration status including:
- Authorization status
- Configuration hierarchy (from global to local)
- Active aliases, functions, and environment variables
- Cache status
- Configuration flags

```bash
dirvana status
```

### `dirvana init`
Create a sample configuration file in the current directory.

```bash
dirvana init
```

### `dirvana validate [config-file]`
Validate a Dirvana configuration file using JSON Schema and custom validation rules. If no file is specified, looks for a config file in the current directory.

```bash
dirvana validate
dirvana validate /path/to/.dirvana.yml
```

Validation checks:
- **JSON Schema validation** (draft-07) for structure and types
- YAML/TOML/JSON syntax errors
- Name conflicts between aliases and functions
- Empty values in aliases, functions, and shell commands
- Invalid environment variable configurations
- Validates alias/function/env var naming conventions

### `dirvana edit`
Open or create a Dirvana configuration file in your editor (`$EDITOR` or `$VISUAL`). If no config exists, creates a new `.dirvana.yml` with helpful comments and automatic JSON Schema validation support.

```bash
dirvana edit
```

**Note**: Generated files automatically include the JSON Schema reference for IDE validation and auto-completion.

### `dirvana schema [output-file]`
Display or export the JSON Schema (draft-07) for Dirvana configuration files. Useful for IDE integration and validation.

```bash
dirvana schema                    # Print to stdout
dirvana schema -o schema.json     # Save to file
dirvana schema myschema.json      # Alternative syntax
```

The schema can be used with:
- **VS Code**: Add `"$schema"` field to your `.dirvana.yml`
- **IntelliJ/WebStorm**: Automatic detection via JSON Schema Store
- **vim/neovim**: Use with yaml-language-server

Example configuration with schema:
```yaml
# yaml-language-server: $schema=https://raw.githubusercontent.com/NikitaCOEUR/dirvana/main/schema/dirvana.schema.json
aliases:
  test: echo "test"
```

### `dirvana hook`
Print shell hook code for manual installation. The hook includes a safety check to ensure the `dirvana` command exists before executing, preventing "command not found" errors.

```bash
dirvana hook --shell bash
dirvana hook --shell zsh
dirvana hook --shell fish
dirvana hook --shell powershell  # Windows PowerShell
dirvana hook --shell pwsh         # PowerShell Core
```

Flags:
- `--shell` : Shell type - bash, zsh, fish, powershell, pwsh, or auto (also via `DIRVANA_SHELL`, default: auto)

### `dirvana setup`
Automatically install shell hook and completion to the appropriate configuration file. If the hook is already installed but outdated, it will be automatically updated.

```bash
dirvana setup --shell bash        # Installs to ~/.bashrc
dirvana setup --shell zsh         # Installs to ~/.zshrc
dirvana setup --shell fish        # Installs to ~/.config/fish/config.fish
dirvana setup --shell powershell  # Installs to ~/Documents/WindowsPowerShell/Microsoft.PowerShell_profile.ps1
dirvana setup --shell pwsh        # Installs to ~/.config/powershell/Microsoft.PowerShell_profile.ps1
```

The setup command uses markers (`# Dirvana shell hook - START/END`) to:
- Detect if the hook is already installed
- Compare the installed version with the current version
- Automatically update the hook if it has changed
- Preserve other content in your shell configuration file
- Automatically install shell completion

Flags:
- `--shell` : Shell type - bash, zsh, fish, powershell, pwsh, or auto (also via `DIRVANA_SHELL`, default: auto)

### `dirvana version`
Show version information.

```bash
dirvana version
```

## Shell Completion

Dirvana supports auto-completion for bash, zsh, fish, and PowerShell.

### Installing Completion

**Bash:**
```bash
# One-time use (current shell only)
source <(dirvana completion bash)

# Permanent (add to ~/.bashrc)
dirvana completion bash > ~/.bash_completion.d/dirvana

# Or for system-wide
sudo dirvana completion bash > /etc/bash_completion.d/dirvana
```

**Zsh:**
```bash
# One-time use (current shell only)
source <(dirvana completion zsh)

# Permanent (add to ~/.zshrc)
dirvana completion zsh > "${fpath[1]}/_dirvana"
# Then reload: compinit
```

**Fish:**
```bash
dirvana completion fish > ~/.config/fish/completions/dirvana.fish
```

**PowerShell:**
```powershell
dirvana completion powershell > dirvana.ps1
# Add to your PowerShell profile
```

## Development

### Prerequisites

- Go 1.21 or later
- [Task](https://taskfile.dev/) (managed via aqua.yaml, or install via `go install github.com/go-task/task/v3/cmd/task@latest`)
- Optional: [aqua](https://aquaproj.github.io/) for dependency management

### Building

```bash
task build
```

### Testing

```bash
# Run unit tests
task test

# Run tests with coverage
task test-coverage

# Run tests with verbose output
task test-verbose

# Run integration tests (Docker required)
task test-integration

# Run specific shell integration test
task test-integration-bash
task test-integration-zsh
task test-integration-fish

# Run all tests (unit + integration)
task test-all
```

#### Integration Tests

Integration tests validate that Dirvana works correctly in real shell environments using Docker containers:

- **Bash** - Tests aliases, functions, and environment variables in Bash 5.2
- **Zsh** - Tests hooks and features in Zsh 5.9
- **Fish** - Tests Fish shell integration

Each test:
1. Builds a Docker image with the specific shell
2. Installs Dirvana and sets up hooks
3. Creates a test configuration
4. Validates that all features work correctly

Run individual shell tests:
```bash
# Build and run specific shell test
docker build -t dirvana-test-bash -f tests/integration/shells/Dockerfile.bash .
docker run --rm dirvana-test-bash
```

### Available Tasks

Run `task` or `task --list` to see all available tasks.

### Project Structure

```
dirvana/
├── cmd/
│   └── dirvana/          # CLI entry point
├── internal/
│   ├── auth/             # Authorization system
│   ├── cache/            # Cache management
│   ├── cli/              # CLI commands implementation
│   ├── config/           # Configuration loading & validation
│   ├── context/          # Directory context management
│   ├── logger/           # Logging
│   └── shell/            # Shell code generation
├── pkg/
│   └── version/          # Version information
├── hooks/                # Shell hook scripts
├── schema/               # JSON Schema for config validation
├── examples/             # Example configurations
└── Taskfile.yml          # Build and test automation
```

## How It Works

1. **Shell Hook**: On every `cd` or terminal open, the shell hook first verifies the `dirvana` command exists, then calls `dirvana export`
2. **Config Discovery**: Dirvana searches for config files:
   - Global config at `~/.config/dirvana/global.yml`
   - Local configs from root directory up to current directory
3. **Authorization Check**: Ensures the directory is authorized for execution
4. **Cache Check**: If configuration hasn't changed, uses cached shell code
5. **Config Merge**: Merges configs in order: global → root → parent → current (child configs override parent values)
6. **Code Generation**: Generates shell code for aliases, functions, and env vars
7. **Evaluation**: Shell hook evaluates the generated code

**Note**: The hook includes built-in safety checks to gracefully handle cases where the `dirvana` command is not available (e.g., if the binary is moved or deleted).

## Cache

Cache is stored in `$XDG_CACHE_HOME/dirvana/cache.json` and includes:
- Folder path
- Config file hash
- Generated shell code
- Timestamp
- Dirvana version
- `local_only` flag

Cache is automatically invalidated when:
- Configuration files change
- Dirvana version changes

## Authorization

Authorized projects are stored in `$XDG_DATA_HOME/dirvana/authorized.json`.

Only authorized projects can execute automatically. This prevents malicious code execution from untrusted directories.

## Release Process

This project uses [GoReleaser](https://goreleaser.com/) for automated releases with semantic versioning based on conventional commits.

### Conventional Commits

All commits must follow the [Conventional Commits](https://www.conventionalcommits.org/) specification:

- `feat:` - New features (minor version bump)
- `fix:` - Bug fixes (patch version bump)
- `perf:` - Performance improvements (patch version bump)
- `refactor:` - Code refactoring (patch version bump)
- `docs:` - Documentation changes (no version bump)
- `test:` - Test changes (no version bump)
- `chore:` - Maintenance tasks (no version bump)
- `ci:` - CI/CD changes (no version bump)

**Breaking changes**: Add `BREAKING CHANGE:` in the commit footer or `!` after the type (e.g., `feat!:`) for major version bumps.

### Creating a Release

1. Ensure all commits follow conventional commit format
2. Create and push a new tag:
   ```bash
   git tag -a v1.0.0 -m "Release v1.0.0"
   git push origin v1.0.0
   ```
3. GitHub Actions will automatically:
   - Run tests
   - Build binaries for multiple platforms
   - Create GitHub release with changelog
   - Publish Docker images to GHCR
   - Update Homebrew tap

### Release Artifacts

Each release includes:
- Pre-built binaries for Linux, macOS, Windows (amd64, arm64)
- Docker images (multi-arch: amd64, arm64)
- Debian/RPM/APK packages
- Homebrew formula
- Checksums and signatures

## Contributing

Contributions are welcome! Please ensure:
- All commits follow [Conventional Commits](https://www.conventionalcommits.org/) format
- All tests pass: `task test`
- Code is formatted: `task fmt`
- Linter passes: `task lint`
- Coverage remains at 90%+

## License

MIT License - See LICENSE file for details

## Author

Nikita C (https://github.com/NikitaCOEUR)
