package shell

import (
	"testing"

	"github.com/NikitaCOEUR/dirvana/internal/config"
	"github.com/stretchr/testify/assert"
)

func TestGenerator_Generate(t *testing.T) {
	g := NewGenerator()

	aliases := map[string]config.AliasConfig{
		"ll": {Command: "ls -la", Completion: nil},
		"gs": {Command: "git status", Completion: nil},
	}

	functions := map[string]string{
		"greet": "echo \"Hello, $1!\"",
		"bye":   "echo \"Goodbye!\"",
	}

	staticEnv := map[string]string{
		"PROJECT_NAME": "myproject",
		"DEBUG":        "true",
	}

	shellEnv := map[string]string{
		"GIT_BRANCH": "git rev-parse --abbrev-ref HEAD",
	}

	code := g.Generate(aliases, functions, staticEnv, shellEnv)

	// With wrapper architecture, aliases point to dirvana exec
	assert.Contains(t, code, "alias ll='dirvana exec ll'")
	assert.Contains(t, code, "alias gs='dirvana exec gs'")
	assert.Contains(t, code, "Using wrapper architecture")

	// Functions are now generated as real shell functions with their body inline
	assert.Contains(t, code, "greet() {")
	assert.Contains(t, code, "bye() {")

	// Static env vars are still exported directly
	assert.Contains(t, code, "export PROJECT_NAME='myproject'")
	assert.Contains(t, code, "export DEBUG='true'")

	// Shell env vars use command substitution to execute commands
	assert.Contains(t, code, "export GIT_BRANCH=\"$(git rev-parse --abbrev-ref HEAD)\"")
}

func TestGenerator_GenerateEmpty(t *testing.T) {
	g := NewGenerator()

	code := g.Generate(nil, nil, nil, nil)

	// Should produce valid but minimal shell code
	assert.NotEmpty(t, code)
	assert.Contains(t, code, "# Generated by Dirvana")
}

func TestGenerator_GenerateAliasesOnly(t *testing.T) {
	g := NewGenerator()

	aliases := map[string]config.AliasConfig{
		"ll": {Command: "ls -la", Completion: nil},
	}

	code := g.Generate(aliases, nil, nil, nil)
	assert.Contains(t, code, "alias ll='dirvana exec ll'")
	assert.NotContains(t, code, "export")
}

func TestGenerator_GenerateFunctionsOnly(t *testing.T) {
	g := NewGenerator()

	functions := map[string]string{
		"greet": "echo \"Hello\"",
	}

	code := g.Generate(nil, functions, nil, nil)
	// Functions are now generated as real shell functions with their body inline
	assert.Contains(t, code, "greet() {")
	assert.Contains(t, code, "echo \"Hello\"")
}

func TestGenerator_GenerateEnvOnly(t *testing.T) {
	g := NewGenerator()

	staticEnv := map[string]string{
		"TEST": "value",
	}

	code := g.Generate(nil, nil, staticEnv, nil)
	assert.Contains(t, code, "export TEST='value'")
}

func TestGenerator_GenerateShellEnvOnly(t *testing.T) {
	g := NewGenerator()

	shellEnv := map[string]string{
		"CURRENT_DIR": "pwd",
		"GIT_BRANCH":  "git branch --show-current",
	}

	code := g.Generate(nil, nil, nil, shellEnv)
	// Shell env vars use command substitution to execute commands
	assert.Contains(t, code, "export CURRENT_DIR=\"$(pwd)\"")
	assert.Contains(t, code, "export GIT_BRANCH=\"$(git branch --show-current)\"")
}

func TestGenerator_EscapeQuotes(t *testing.T) {
	g := NewGenerator()

	aliases := map[string]config.AliasConfig{
		"test": {Command: "echo 'it\\'s working'", Completion: nil},
	}

	staticEnv := map[string]string{
		"VAR": "value with 'quotes'",
	}

	code := g.Generate(aliases, nil, staticEnv, nil)
	// Wrapper architecture still uses the alias
	assert.Contains(t, code, "alias test='dirvana exec test'")
	// Env vars should escape quotes
	assert.Contains(t, code, "export VAR='value with '\\''quotes'\\'''")
}

func TestGenerator_MultilineFunction(t *testing.T) {
	g := NewGenerator()

	functions := map[string]string{
		"complex": "if [ -z \"$1\" ]; then\n  echo \"No args\"\nelse\n  echo \"Args: $@\"\nfi",
	}

	code := g.Generate(nil, functions, nil, nil)
	// Functions are now generated as real shell functions with their body inline
	assert.Contains(t, code, "complex() {")
	assert.Contains(t, code, "if [ -z \"$1\" ]")
}

func TestGenerator_SortedOutput(t *testing.T) {
	g := NewGenerator()

	aliases := map[string]config.AliasConfig{
		"zz": {Command: "zzz", Completion: nil},
		"aa": {Command: "aaa", Completion: nil},
		"mm": {Command: "mmm", Completion: nil},
	}

	code := g.Generate(aliases, nil, nil, nil)

	// Check they appear in sorted order (aa before mm before zz)
	aaPos := indexOf(code, "alias aa=")
	mmPos := indexOf(code, "alias mm=")
	zzPos := indexOf(code, "alias zz=")

	assert.Less(t, aaPos, mmPos, "aa should come before mm")
	assert.Less(t, mmPos, zzPos, "mm should come before zz")
}

func TestGenerator_EmptyValues(t *testing.T) {
	g := NewGenerator()

	aliases := map[string]config.AliasConfig{
		"empty": {Command: "", Completion: nil},
	}

	staticEnv := map[string]string{
		"EMPTY_VAR": "",
	}

	code := g.Generate(aliases, nil, staticEnv, nil)

	// Empty values should still be handled
	assert.Contains(t, code, "alias empty=")
	assert.Contains(t, code, "export EMPTY_VAR=")
}

func TestGenerator_CompletionInherit(t *testing.T) {
	g := NewGenerator()

	aliases := map[string]config.AliasConfig{
		"gp": {Command: "git push", Completion: "git"},
	}

	code := g.Generate(aliases, nil, nil, nil)
	// With wrapper architecture, aliases point to dirvana exec
	assert.Contains(t, code, "alias gp='dirvana exec gp'")
	assert.Contains(t, code, "Using wrapper architecture")
}

func TestGenerator_CompletionDisabled(t *testing.T) {
	g := NewGenerator()

	aliases := map[string]config.AliasConfig{
		"noop": {Command: "echo nothing", Completion: false},
	}

	code := g.Generate(aliases, nil, nil, nil)
	// With wrapper architecture, aliases point to dirvana exec
	assert.Contains(t, code, "alias noop='dirvana exec noop'")
	assert.Contains(t, code, "Using wrapper architecture")
}

func TestGenerator_CompletionCustom(t *testing.T) {
	g := NewGenerator()

	aliases := map[string]config.AliasConfig{
		"deploy": {
			Command: "./deploy.sh",
			Completion: config.CompletionConfig{
				Bash: "complete -W 'dev staging prod' deploy",
				Zsh:  "compdef '_arguments \"1: :(dev staging prod)\"' deploy",
			},
		},
	}

	code := g.Generate(aliases, nil, nil, nil)
	// With wrapper architecture, aliases point to dirvana exec
	assert.Contains(t, code, "alias deploy='dirvana exec deploy'")
	assert.Contains(t, code, "Using wrapper architecture")
	// Custom completions are handled by dirvana completion command now
}

// Helper function to find index of substring
func indexOf(s, substr string) int {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return i
		}
	}
	return -1
}
