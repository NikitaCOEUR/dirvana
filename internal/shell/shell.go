// Package shell generates shell code from Dirvana configuration.
package shell

import (
	"fmt"
	"sort"
	"strings"

	"github.com/NikitaCOEUR/dirvana/internal/config"
)

// Generator generates shell code from configuration
type Generator struct {
	UseWrappers bool // If true, use dirvana exec wrappers instead of direct aliases
}

// NewGenerator creates a new shell code generator
func NewGenerator() *Generator {
	return &Generator{
		UseWrappers: true, // Enable wrappers by default for better performance
	}
}

// Generate creates shell code for aliases, functions, and environment variables
// staticEnv contains simple string values, shellEnv contains shell commands to execute
func (g *Generator) Generate(aliases map[string]config.AliasConfig, functions, staticEnv, shellEnv map[string]string) string {
	var parts []string

	// Add header comment
	parts = append(parts, "# Generated by Dirvana - Do not edit manually")

	if g.UseWrappers {
		// NEW APPROACH: Generate lightweight wrappers using dirvana exec
		return g.generateWithWrappers(aliases, functions, staticEnv, shellEnv)
	}

	// OLD APPROACH: Generate full shell code (kept for backwards compatibility)
	// Generate aliases
	if len(aliases) > 0 {
		parts = append(parts, "\n# Aliases")
		keys := sortedKeysFromAliases(aliases)
		for _, key := range keys {
			aliasConf := aliases[key]
			parts = append(parts, fmt.Sprintf("alias %s='%s'", key, escapeValue(aliasConf.Command)))
		}

		// Add shell completion for aliases
		parts = append(parts, "\n# Shell completions for aliases")
		for _, key := range keys {
			aliasConf := aliases[key]
			parts = append(parts, generateCompletion(key, aliasConf)...)
		}
	}

	// Generate functions
	if len(functions) > 0 {
		parts = append(parts, "\n# Functions")
		keys := sortedKeys(functions)
		for _, key := range keys {
			body := functions[key]
			parts = append(parts, fmt.Sprintf("%s() {\n%s\n}", key, indent(body)))
		}
	}

	// Generate static environment variables
	if len(staticEnv) > 0 {
		parts = append(parts, "\n# Environment Variables")
		keys := sortedKeys(staticEnv)
		for _, key := range keys {
			value := staticEnv[key]
			parts = append(parts, fmt.Sprintf("export %s='%s'", key, escapeValue(value)))
		}
	}

	// Generate dynamic environment variables (from shell commands)
	if len(shellEnv) > 0 {
		parts = append(parts, "\n# Dynamic Environment Variables")
		keys := sortedKeys(shellEnv)
		for _, key := range keys {
			shellCmd := shellEnv[key]
			// Use command substitution to execute shell command
			parts = append(parts, fmt.Sprintf("export %s=\"$(%s)\"", key, shellCmd))
		}
	}

	return strings.Join(parts, "\n") + "\n"
}

// escapeValue escapes single quotes in values
func escapeValue(s string) string {
	return strings.ReplaceAll(s, "'", "'\\''")
}

// indent adds indentation to multiline strings
func indent(s string) string {
	lines := strings.Split(s, "\n")
	for i, line := range lines {
		if line != "" {
			lines[i] = "  " + line
		}
	}
	return strings.Join(lines, "\n")
}

// sortedKeys returns sorted keys from a map for deterministic output
func sortedKeys(m map[string]string) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

// sortedKeysFromAliases returns sorted keys from alias map for deterministic output
func sortedKeysFromAliases(m map[string]config.AliasConfig) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

// generateCompletion generates shell completion code for an alias
func generateCompletion(aliasName string, aliasConf config.AliasConfig) []string {
	var lines []string

	switch comp := aliasConf.Completion.(type) {
	case nil:
		// Auto-detect: extract first word from command
		fields := strings.Fields(aliasConf.Command)
		if len(fields) > 0 {
			baseCmd := fields[0]
			// Bash: Check if completion exists for base command and copy it
			lines = append(lines, fmt.Sprintf("if complete -p %s &>/dev/null; then", baseCmd))
			lines = append(lines, fmt.Sprintf("  eval \"$(complete -p %s | sed 's/ %s$/ %s/')\"", baseCmd, baseCmd, aliasName))
			lines = append(lines, "else")
			lines = append(lines, fmt.Sprintf("  complete -o bashdefault -o default %s 2>/dev/null || true", aliasName))
			lines = append(lines, "fi")
			// Zsh: copy completions from base command (this works perfectly)
			lines = append(lines, fmt.Sprintf("compdef %s=%s 2>/dev/null || true", aliasName, baseCmd))
		}

	case string:
		// Inherit from specified command
		lines = append(lines, fmt.Sprintf("if complete -p %s &>/dev/null; then", comp))
		lines = append(lines, fmt.Sprintf("  eval \"$(complete -p %s | sed 's/ %s$/ %s/')\"", comp, comp, aliasName))
		lines = append(lines, "else")
		lines = append(lines, fmt.Sprintf("  complete -o bashdefault -o default %s 2>/dev/null || true", aliasName))
		lines = append(lines, "fi")
		lines = append(lines, fmt.Sprintf("compdef %s=%s 2>/dev/null || true", aliasName, comp))

	case bool:
		// false = no completion (do nothing)
		// true would be weird but we'll treat it as auto-detect
		if comp {
			fields := strings.Fields(aliasConf.Command)
			if len(fields) > 0 {
				baseCmd := fields[0]
				lines = append(lines, fmt.Sprintf("complete -o bashdefault -o default %s 2>/dev/null || true", aliasName))
				lines = append(lines, fmt.Sprintf("compdef %s=%s 2>/dev/null || true", aliasName, baseCmd))
			}
		}

	case config.CompletionConfig:
		// Custom completion code
		if comp.Bash != "" {
			lines = append(lines, comp.Bash)
		}
		if comp.Zsh != "" {
			lines = append(lines, comp.Zsh)
		}
	}

	return lines
}

// generateWithWrappers generates minimal shell code using dirvana exec wrappers
// This is much faster than the old approach as it doesn't generate complex completion logic
func (g *Generator) generateWithWrappers(aliases map[string]config.AliasConfig, functions, staticEnv, shellEnv map[string]string) string {
	var parts []string

	parts = append(parts, "# Generated by Dirvana - Do not edit manually")
	parts = append(parts, "# Using wrapper architecture for better performance")

	// Collect all alias and function names for the completion function
	var allNames []string

	// Generate simple alias wrappers
	if len(aliases) > 0 {
		parts = append(parts, "\n# Aliases (using dirvana exec wrapper)")
		keys := sortedKeysFromAliases(aliases)
		for _, key := range keys {
			parts = append(parts, fmt.Sprintf("alias %s='dirvana exec %s'", key, key))
			allNames = append(allNames, key)
		}
	}

	// Generate function wrappers
	if len(functions) > 0 {
		parts = append(parts, "\n# Functions (using dirvana exec wrapper)")
		keys := sortedKeys(functions)
		for _, key := range keys {
			parts = append(parts, fmt.Sprintf("alias %s='dirvana exec %s'", key, key))
			allNames = append(allNames, key)
		}
	}

	// Generate static environment variables (unchanged)
	if len(staticEnv) > 0 {
		parts = append(parts, "\n# Environment Variables")
		keys := sortedKeys(staticEnv)
		for _, key := range keys {
			value := staticEnv[key]
			parts = append(parts, fmt.Sprintf("export %s='%s'", key, escapeValue(value)))
		}
	}

	// Generate dynamic environment variables (unchanged)
	if len(shellEnv) > 0 {
		parts = append(parts, "\n# Dynamic Environment Variables")
		keys := sortedKeys(shellEnv)
		for _, key := range keys {
			value := shellEnv[key]
			parts = append(parts, fmt.Sprintf("export %s='%s'", key, escapeValue(value)))
		}
	}

	// Generate simple unified completion function
	// For now, we'll just use default file completion
	// TODO: Implement proper completion via dirvana completion command
	if len(allNames) > 0 {
		parts = append(parts, "\n# Completions (placeholder - uses default file completion)")
		parts = append(parts, "# TODO: Implement dirvana completion integration")
	}

	return strings.Join(parts, "\n") + "\n"
}
