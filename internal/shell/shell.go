// Package shell generates shell code from Dirvana configuration.
package shell

import (
	"fmt"
	"sort"
	"strings"

	"github.com/NikitaCOEUR/dirvana/internal/config"
)

// Generator generates shell code from configuration
type Generator struct{}

// NewGenerator creates a new shell code generator
func NewGenerator() *Generator {
	return &Generator{}
}

// Generate creates shell code for aliases, functions, and environment variables
// staticEnv contains simple string values, shellEnv contains shell commands to execute
func (g *Generator) Generate(aliases map[string]config.AliasConfig, functions, staticEnv, shellEnv map[string]string) string {
	var parts []string

	// Add header comment
	parts = append(parts, "# Generated by Dirvana - Do not edit manually")

	// Generate aliases
	if len(aliases) > 0 {
		parts = append(parts, "\n# Aliases")
		keys := sortedKeysFromAliases(aliases)
		for _, key := range keys {
			aliasConf := aliases[key]
			parts = append(parts, fmt.Sprintf("alias %s='%s'", key, escapeValue(aliasConf.Command)))
		}

		// Add shell completion for aliases
		parts = append(parts, "\n# Shell completions for aliases")
		for _, key := range keys {
			aliasConf := aliases[key]
			parts = append(parts, generateCompletion(key, aliasConf)...)
		}
	}

	// Generate functions
	if len(functions) > 0 {
		parts = append(parts, "\n# Functions")
		keys := sortedKeys(functions)
		for _, key := range keys {
			body := functions[key]
			parts = append(parts, fmt.Sprintf("%s() {\n%s\n}", key, indent(body)))
		}
	}

	// Generate static environment variables
	if len(staticEnv) > 0 {
		parts = append(parts, "\n# Environment Variables")
		keys := sortedKeys(staticEnv)
		for _, key := range keys {
			value := staticEnv[key]
			parts = append(parts, fmt.Sprintf("export %s='%s'", key, escapeValue(value)))
		}
	}

	// Generate dynamic environment variables (from shell commands)
	if len(shellEnv) > 0 {
		parts = append(parts, "\n# Dynamic Environment Variables")
		keys := sortedKeys(shellEnv)
		for _, key := range keys {
			shellCmd := shellEnv[key]
			// Use command substitution to execute shell command
			parts = append(parts, fmt.Sprintf("export %s=\"$(%s)\"", key, shellCmd))
		}
	}

	return strings.Join(parts, "\n") + "\n"
}

// escapeValue escapes single quotes in values
func escapeValue(s string) string {
	return strings.ReplaceAll(s, "'", "'\\''")
}

// indent adds indentation to multiline strings
func indent(s string) string {
	lines := strings.Split(s, "\n")
	for i, line := range lines {
		if line != "" {
			lines[i] = "  " + line
		}
	}
	return strings.Join(lines, "\n")
}

// sortedKeys returns sorted keys from a map for deterministic output
func sortedKeys(m map[string]string) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

// sortedKeysFromAliases returns sorted keys from alias map for deterministic output
func sortedKeysFromAliases(m map[string]config.AliasConfig) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

// generateCompletion generates shell completion code for an alias
func generateCompletion(aliasName string, aliasConf config.AliasConfig) []string {
	var lines []string

	switch comp := aliasConf.Completion.(type) {
	case nil:
		// Auto-detect: extract first word from command
		fields := strings.Fields(aliasConf.Command)
		if len(fields) > 0 {
			baseCmd := fields[0]
			// Bash: Use __start_<cmd> function if it exists (works for kubectl, docker, etc)
			// Otherwise fall back to basic completion
			lines = append(lines, fmt.Sprintf("complete -o default -F __start_%s %s 2>/dev/null || complete -o bashdefault -o default %s 2>/dev/null || true", baseCmd, aliasName, aliasName))
			// Zsh: copy completions from base command (this works perfectly)
			lines = append(lines, fmt.Sprintf("compdef %s=%s 2>/dev/null || true", aliasName, baseCmd))
		}

	case string:
		// Inherit from specified command
		lines = append(lines, fmt.Sprintf("complete -o default -F __start_%s %s 2>/dev/null || complete -o bashdefault -o default %s 2>/dev/null || true", comp, aliasName, aliasName))
		lines = append(lines, fmt.Sprintf("compdef %s=%s 2>/dev/null || true", aliasName, comp))

	case bool:
		// false = no completion (do nothing)
		// true would be weird but we'll treat it as auto-detect
		if comp {
			fields := strings.Fields(aliasConf.Command)
			if len(fields) > 0 {
				baseCmd := fields[0]
				lines = append(lines, fmt.Sprintf("complete -o bashdefault -o default %s 2>/dev/null || true", aliasName))
				lines = append(lines, fmt.Sprintf("compdef %s=%s 2>/dev/null || true", aliasName, baseCmd))
			}
		}

	case config.CompletionConfig:
		// Custom completion code
		if comp.Bash != "" {
			lines = append(lines, comp.Bash)
		}
		if comp.Zsh != "" {
			lines = append(lines, comp.Zsh)
		}
	}

	return lines
}
