// Package shell generates shell code from Dirvana configuration.
package shell

import (
	"fmt"
	"sort"
	"strings"

	"github.com/NikitaCOEUR/dirvana/internal/config"
)

// Generator generates shell code from configuration
type Generator struct {
	UseWrappers bool // If true, use dirvana exec wrappers instead of direct aliases
}

// NewGenerator creates a new shell code generator
func NewGenerator() *Generator {
	return &Generator{
		UseWrappers: true, // Enable wrappers by default for better performance
	}
}

// Generate creates shell code for aliases, functions, and environment variables
// staticEnv contains simple string values, shellEnv contains shell commands to execute
func (g *Generator) Generate(aliases map[string]config.AliasConfig, functions, staticEnv, shellEnv map[string]string) string {
	var parts []string

	// Add header comment
	parts = append(parts, "# Generated by Dirvana - Do not edit manually")

	if g.UseWrappers {
		// NEW APPROACH: Generate lightweight wrappers using dirvana exec
		return g.generateWithWrappers(aliases, functions, staticEnv, shellEnv)
	}

	// OLD APPROACH: Generate full shell code (kept for backwards compatibility)
	// Generate aliases
	if len(aliases) > 0 {
		parts = append(parts, "\n# Aliases")
		keys := sortedKeysFromAliases(aliases)
		for _, key := range keys {
			aliasConf := aliases[key]
			parts = append(parts, fmt.Sprintf("alias %s='%s'", key, escapeValue(aliasConf.Command)))
		}

		// Add shell completion for aliases
		parts = append(parts, "\n# Shell completions for aliases")
		for _, key := range keys {
			aliasConf := aliases[key]
			parts = append(parts, generateCompletion(key, aliasConf)...)
		}
	}

	// Generate functions
	if len(functions) > 0 {
		parts = append(parts, "\n# Functions")
		keys := sortedKeys(functions)
		for _, key := range keys {
			body := functions[key]
			parts = append(parts, fmt.Sprintf("%s() {\n%s\n}", key, indent(body)))
		}
	}

	// Generate static environment variables
	if len(staticEnv) > 0 {
		parts = append(parts, "\n# Environment Variables")
		keys := sortedKeys(staticEnv)
		for _, key := range keys {
			value := staticEnv[key]
			parts = append(parts, fmt.Sprintf("export %s='%s'", key, escapeValue(value)))
		}
	}

	// Generate dynamic environment variables (from shell commands)
	if len(shellEnv) > 0 {
		parts = append(parts, "\n# Dynamic Environment Variables")
		keys := sortedKeys(shellEnv)
		for _, key := range keys {
			shellCmd := shellEnv[key]
			// Use command substitution to execute shell command
			parts = append(parts, fmt.Sprintf("export %s=\"$(%s)\"", key, shellCmd))
		}
	}

	return strings.Join(parts, "\n") + "\n"
}

// escapeValue escapes single quotes in values
func escapeValue(s string) string {
	return strings.ReplaceAll(s, "'", "'\\''")
}

// indent adds indentation to multiline strings
func indent(s string) string {
	lines := strings.Split(s, "\n")
	for i, line := range lines {
		if line != "" {
			lines[i] = "  " + line
		}
	}
	return strings.Join(lines, "\n")
}

// sortedKeys returns sorted keys from a map for deterministic output
func sortedKeys(m map[string]string) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

// sortedKeysFromAliases returns sorted keys from alias map for deterministic output
func sortedKeysFromAliases(m map[string]config.AliasConfig) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

// generateCompletion generates shell completion code for an alias
func generateCompletion(aliasName string, aliasConf config.AliasConfig) []string {
	var lines []string

	switch comp := aliasConf.Completion.(type) {
	case nil:
		// Auto-detect: extract first word from command
		fields := strings.Fields(aliasConf.Command)
		if len(fields) > 0 {
			baseCmd := fields[0]
			// Bash: Check if completion exists for base command and copy it
			lines = append(lines, fmt.Sprintf("if complete -p %s &>/dev/null; then", baseCmd))
			lines = append(lines, fmt.Sprintf("  eval \"$(complete -p %s | sed 's/ %s$/ %s/')\"", baseCmd, baseCmd, aliasName))
			lines = append(lines, "else")
			lines = append(lines, fmt.Sprintf("  complete -o bashdefault -o default %s 2>/dev/null || true", aliasName))
			lines = append(lines, "fi")
			// Zsh: copy completions from base command (this works perfectly)
			lines = append(lines, fmt.Sprintf("compdef %s=%s 2>/dev/null || true", aliasName, baseCmd))
		}

	case string:
		// Inherit from specified command
		lines = append(lines, fmt.Sprintf("if complete -p %s &>/dev/null; then", comp))
		lines = append(lines, fmt.Sprintf("  eval \"$(complete -p %s | sed 's/ %s$/ %s/')\"", comp, comp, aliasName))
		lines = append(lines, "else")
		lines = append(lines, fmt.Sprintf("  complete -o bashdefault -o default %s 2>/dev/null || true", aliasName))
		lines = append(lines, "fi")
		lines = append(lines, fmt.Sprintf("compdef %s=%s 2>/dev/null || true", aliasName, comp))

	case bool:
		// false = no completion (do nothing)
		// true would be weird but we'll treat it as auto-detect
		if comp {
			fields := strings.Fields(aliasConf.Command)
			if len(fields) > 0 {
				baseCmd := fields[0]
				lines = append(lines, fmt.Sprintf("complete -o bashdefault -o default %s 2>/dev/null || true", aliasName))
				lines = append(lines, fmt.Sprintf("compdef %s=%s 2>/dev/null || true", aliasName, baseCmd))
			}
		}

	case config.CompletionConfig:
		// Custom completion code
		if comp.Bash != "" {
			lines = append(lines, comp.Bash)
		}
		if comp.Zsh != "" {
			lines = append(lines, comp.Zsh)
		}
	}

	return lines
}

// generateWithWrappers generates minimal shell code using dirvana exec wrappers
// This is much faster than the old approach as it doesn't generate complex completion logic
func (g *Generator) generateWithWrappers(aliases map[string]config.AliasConfig, functions, staticEnv, shellEnv map[string]string) string {
	var parts []string

	parts = append(parts, "# Generated by Dirvana - Do not edit manually")
	parts = append(parts, "# Using wrapper architecture for better performance")

	// Collect all alias and function names for the completion function
	var allNames []string

	// Generate simple alias wrappers
	if len(aliases) > 0 {
		parts = append(parts, "\n# Aliases (using dirvana exec wrapper)")
		keys := sortedKeysFromAliases(aliases)
		for _, key := range keys {
			parts = append(parts, fmt.Sprintf("alias %s='dirvana exec %s'", key, key))
			allNames = append(allNames, key)
		}
	}

	// Generate function wrappers
	if len(functions) > 0 {
		parts = append(parts, "\n# Functions (using dirvana exec wrapper)")
		keys := sortedKeys(functions)
		for _, key := range keys {
			parts = append(parts, fmt.Sprintf("alias %s='dirvana exec %s'", key, key))
			allNames = append(allNames, key)
		}
	}

	// Generate static environment variables (unchanged)
	if len(staticEnv) > 0 {
		parts = append(parts, "\n# Environment Variables")
		keys := sortedKeys(staticEnv)
		for _, key := range keys {
			value := staticEnv[key]
			parts = append(parts, fmt.Sprintf("export %s='%s'", key, escapeValue(value)))
		}
	}

	// Generate dynamic environment variables (unchanged)
	if len(shellEnv) > 0 {
		parts = append(parts, "\n# Dynamic Environment Variables")
		keys := sortedKeys(shellEnv)
		for _, key := range keys {
			value := shellEnv[key]
			parts = append(parts, fmt.Sprintf("export %s='%s'", key, escapeValue(value)))
		}
	}

	// Generate smart completion function for bash and zsh
	if len(allNames) > 0 {
		parts = append(parts, "\n# Completions (via dirvana completion)")
		parts = append(parts, generateCompletionFunction(allNames)...)
	}

	return strings.Join(parts, "\n") + "\n"
}

// generateCompletionFunction generates bash and zsh completion functions
// that delegate to `dirvana completion`
func generateCompletionFunction(aliases []string) []string {
	var lines []string

	// Bash completion function
	lines = append(lines, "__dirvana_complete() {")
	lines = append(lines, "  local cur prev words cword")
	lines = append(lines, "  _get_comp_words_by_ref -n : cur prev words cword 2>/dev/null || {")
	lines = append(lines, "    cur=\"${COMP_WORDS[COMP_CWORD]}\"")
	lines = append(lines, "    prev=\"${COMP_WORDS[COMP_CWORD-1]}\"")
	lines = append(lines, "    words=(\"${COMP_WORDS[@]}\")")
	lines = append(lines, "    cword=$COMP_CWORD")
	lines = append(lines, "  }")
	lines = append(lines, "")
	lines = append(lines, "  # Let dirvana handle ALL completion logic (fuzzy matching, filtering, etc.)")
	lines = append(lines, "  local IFS=$'\\n'")
	lines = append(lines, "  local suggestions")
	lines = append(lines, "  suggestions=($(DIRVANA_COMP_CWORD=$cword dirvana completion \"${words[@]}\" 2>/dev/null))")
	lines = append(lines, "")
	lines = append(lines, "  if [ ${#suggestions[@]} -gt 0 ]; then")
	lines = append(lines, "    COMPREPLY=()")
	lines = append(lines, "    for suggestion in \"${suggestions[@]}\"; do")
	lines = append(lines, "      COMPREPLY+=(\"$suggestion\")")
	lines = append(lines, "    done")
	lines = append(lines, "")
	lines = append(lines, "    # Format descriptions like kubectl does")
	lines = append(lines, "    __dirvana_format_descriptions")
	lines = append(lines, "  else")
	lines = append(lines, "    # Fallback to file completion")
	lines = append(lines, "    COMPREPLY=($(compgen -f -- \"$cur\"))")
	lines = append(lines, "  fi")
	lines = append(lines, "}")
	lines = append(lines, "")
	lines = append(lines, "# Format completion descriptions (value\\tdesc -> value  (desc))")
	lines = append(lines, "__dirvana_format_descriptions() {")
	lines = append(lines, "  local tab=$'\\t'")
	lines = append(lines, "  local comp desc maxdesclength longest=0")
	lines = append(lines, "  local i ci")
	lines = append(lines, "")
	lines = append(lines, "  # Find longest completion for alignment")
	lines = append(lines, "  for ci in \"${!COMPREPLY[@]}\"; do")
	lines = append(lines, "    comp=\"${COMPREPLY[ci]%%$tab*}\"")
	lines = append(lines, "    if ((${#comp} > longest)); then")
	lines = append(lines, "      longest=${#comp}")
	lines = append(lines, "    fi")
	lines = append(lines, "  done")
	lines = append(lines, "")
	lines = append(lines, "  # Format each completion with description")
	lines = append(lines, "  for ci in \"${!COMPREPLY[@]}\"; do")
	lines = append(lines, "    comp=\"${COMPREPLY[ci]}\"")
	lines = append(lines, "    if [[ \"$comp\" == *\"$tab\"* ]]; then")
	lines = append(lines, "      desc=\"${comp#*$tab}\"")
	lines = append(lines, "      comp=\"${comp%%$tab*}\"")
	lines = append(lines, "")
	lines = append(lines, "      # Calculate max description length")
	lines = append(lines, "      maxdesclength=$((COLUMNS - longest - 4))")
	lines = append(lines, "      if ((maxdesclength > 8)); then")
	lines = append(lines, "        # Pad completion to align descriptions")
	lines = append(lines, "        for ((i = ${#comp}; i < longest; i++)); do")
	lines = append(lines, "          comp+=\" \"")
	lines = append(lines, "        done")
	lines = append(lines, "      else")
	lines = append(lines, "        maxdesclength=$((COLUMNS - ${#comp} - 4))")
	lines = append(lines, "      fi")
	lines = append(lines, "")
	lines = append(lines, "      # Truncate description if too long")
	lines = append(lines, "      if ((maxdesclength > 0)); then")
	lines = append(lines, "        if ((${#desc} > maxdesclength)); then")
	lines = append(lines, "          desc=\"${desc:0:$((maxdesclength - 1))}…\"")
	lines = append(lines, "        fi")
	lines = append(lines, "        comp+=\"  ($desc)\"")
	lines = append(lines, "      fi")
	lines = append(lines, "")
	lines = append(lines, "      COMPREPLY[ci]=\"$comp\"")
	lines = append(lines, "    fi")
	lines = append(lines, "  done")
	lines = append(lines, "")
	lines = append(lines, "  # If single completion, strip description for direct insertion")
	lines = append(lines, "  if [ ${#COMPREPLY[@]} -eq 1 ]; then")
	lines = append(lines, "    COMPREPLY[0]=\"${COMPREPLY[0]%% (*}\"")
	lines = append(lines, "  fi")
	lines = append(lines, "}")
	lines = append(lines, "")

	// Register bash completion for all aliases
	// Use -o nosort to preserve dirvana's ordering (by fuzzy match quality)
	aliasStr := strings.Join(aliases, " ")
	lines = append(lines, fmt.Sprintf("complete -o nosort -F __dirvana_complete %s 2>/dev/null || true", aliasStr))
	lines = append(lines, "")

	// Zsh completion function (simpler - just delegate to base command completion)
	lines = append(lines, "# Zsh completions")
	for _, alias := range aliases {
		// For zsh, we'll use a simple approach: try to copy completion from base command
		// The actual smart completion happens in dirvana completion
		lines = append(lines, fmt.Sprintf("compdef __dirvana_complete_zsh %s 2>/dev/null || true", alias))
	}

	return lines
}
