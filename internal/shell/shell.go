// Package shell generates shell code from Dirvana configuration.
package shell

import (
	"fmt"
	"sort"
	"strings"

	"github.com/NikitaCOEUR/dirvana/internal/config"
)

// Generator generates shell code from configuration
type Generator struct {
	Shell string // Target shell: "bash", "zsh", or "" for both
}

// NewGenerator creates a new shell code generator
func NewGenerator() *Generator {
	return &Generator{
		Shell: "", // Generate for both shells by default
	}
}

// WithShell sets the target shell
func (g *Generator) WithShell(shell string) *Generator {
	g.Shell = shell
	return g
}

// Generate creates shell code for aliases, functions, and environment variables
// staticEnv contains simple string values, shellEnv contains shell commands to execute
func (g *Generator) Generate(aliases map[string]config.AliasConfig, functions, staticEnv, shellEnv map[string]string) string {
	// Generate lightweight wrappers using dirvana exec
	return g.generateWithWrappers(aliases, functions, staticEnv, shellEnv)
}

// escapeValue escapes single quotes in values
func escapeValue(s string) string {
	return strings.ReplaceAll(s, "'", "'\\''")
}

// indent adds indentation to multiline strings
func indent(s string) string {
	lines := strings.Split(s, "\n")
	for i, line := range lines {
		if line != "" {
			lines[i] = "  " + line
		}
	}
	return strings.Join(lines, "\n")
}

// sortedKeys returns sorted keys from a map for deterministic output
func sortedKeys(m map[string]string) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

// sortedKeysFromAliases returns sorted keys from alias map for deterministic output
func sortedKeysFromAliases(m map[string]config.AliasConfig) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

// generateWithWrappers generates minimal shell code using dirvana exec wrappers
// This is much faster than the old approach as it doesn't generate complex completion logic
func (g *Generator) generateWithWrappers(aliases map[string]config.AliasConfig, functions, staticEnv, shellEnv map[string]string) string {
	var parts []string

	parts = append(parts, "# Generated by Dirvana - Do not edit manually")
	parts = append(parts, "# Using wrapper architecture for better performance")

	// Collect all alias and function names for the completion function
	var allNames []string

	// For zsh and fish, we need to use functions instead of aliases for completion to work
	// For bash, aliases work fine
	useShellFunctions := (g.Shell == shellZsh || g.Shell == shellFish)

	// Generate simple alias/function wrappers
	if len(aliases) > 0 {
		if useShellFunctions {
			if g.Shell == shellFish {
				parts = append(parts, "\n# Aliases (using dirvana exec wrapper as functions)")
				keys := sortedKeysFromAliases(aliases)
				for _, key := range keys {
					// Fish uses a different function syntax
					parts = append(parts, fmt.Sprintf("function %s; dirvana exec %s $argv; end", key, key))
					allNames = append(allNames, key)
				}
			} else {
				parts = append(parts, "\n# Aliases (using dirvana exec wrapper as functions)")
				keys := sortedKeysFromAliases(aliases)
				for _, key := range keys {
					// Clean up any existing completion before defining function
					// This prevents completion conflicts when reusing alias names
					parts = append(parts, fmt.Sprintf("complete -r %s 2>/dev/null || true", key))
					parts = append(parts, fmt.Sprintf("%s() { dirvana exec %s \"$@\"; }", key, key))
					allNames = append(allNames, key)
				}
			}
		} else {
			parts = append(parts, "\n# Aliases (using dirvana exec wrapper)")
			keys := sortedKeysFromAliases(aliases)
			for _, key := range keys {
				// Clean up any existing completion before defining alias
				// This prevents completion conflicts when reusing alias names
				parts = append(parts, fmt.Sprintf("complete -r %s 2>/dev/null || true", key))
				parts = append(parts, fmt.Sprintf("alias %s='dirvana exec %s'", key, key))
				allNames = append(allNames, key)
			}
		}
	}

	// Generate real shell functions
	// Functions contain actual shell code and must be defined directly (not via dirvana exec)
	if len(functions) > 0 {
		parts = append(parts, "\n# Functions")
		keys := sortedKeys(functions)
		for _, key := range keys {
			body := functions[key]
			if g.Shell == shellFish {
				// Fish syntax: function name; ...; end
				parts = append(parts, fmt.Sprintf("function %s\n%s\nend", key, indent(body)))
			} else {
				// Bash/Zsh syntax: name() { ...; }
				parts = append(parts, fmt.Sprintf("%s() {\n%s\n}", key, indent(body)))
			}
		}
	}

	// Generate static environment variables
	if len(staticEnv) > 0 {
		parts = append(parts, "\n# Environment Variables")
		keys := sortedKeys(staticEnv)
		for _, key := range keys {
			value := staticEnv[key]
			if g.Shell == shellFish {
				// Fish syntax: set -gx VAR value
				parts = append(parts, fmt.Sprintf("set -gx %s '%s'", key, escapeValue(value)))
			} else {
				// Bash/Zsh syntax: export VAR=value
				parts = append(parts, fmt.Sprintf("export %s='%s'", key, escapeValue(value)))
			}
		}
	}

	// Generate dynamic environment variables (shell commands that get executed)
	if len(shellEnv) > 0 {
		parts = append(parts, "\n# Dynamic Environment Variables")
		keys := sortedKeys(shellEnv)
		for _, key := range keys {
			shellCmd := shellEnv[key]
			if g.Shell == shellFish {
				// Fish syntax: set -gx VAR (command)
				parts = append(parts, fmt.Sprintf("set -gx %s (%s)", key, shellCmd))
			} else {
				// Bash/Zsh syntax: export VAR="$(command)"
				parts = append(parts, fmt.Sprintf("export %s=\"$(%s)\"", key, shellCmd))
			}
		}
	}

	// Generate smart completion function for bash and zsh
	if len(allNames) > 0 {
		parts = append(parts, "\n# Completions (via dirvana completion)")
		completionGen := NewCompletionGenerator(g.Shell)
		parts = append(parts, completionGen.GenerateCompletionFunction(allNames)...)
	}

	return strings.Join(parts, "\n") + "\n"
}
